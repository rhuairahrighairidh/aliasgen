package main

import (
	"go/types"
	"sort"
)

const aliasTemplate = `// nolint
// DO NOT EDIT - generated by aliasgen tool (github.com/rhuairahrighairidh/aliasgen)
package {{.TargetPackageName}}
{{ if .Imports }}
import ({{ range .Imports }}
	"{{.}}"{{end}}
)
{{end -}}

{{ if .Consts }}
const ({{ range .Consts }}
	{{.Name}} = {{.Pkg}}.{{.Name}}{{end}}
)
{{end -}}

{{if .HasVarsOrFuncs}}
var ({{if .Funcs}}
	// function aliases{{ range .Funcs }}
	{{.Name}} = {{.Pkg}}.{{.Name}}{{end}}{{end}}{{if .HasVarsAndFuncs}}
{{end}}{{if .Vars}}
	// variable aliases{{ range .Vars }}
	{{.Name}} = {{.Pkg}}.{{.Name}}{{end}}{{end}}
)
{{end -}}

{{ if .Types }}
type ({{ range .Types }}
	{{.Name}} = {{.Pkg}}.{{.Name}}{{end}}
)
{{end}}
`

// TemplateData stores alias information in a convenient format for adding to a go template.
type TemplateData struct {
	TargetPackageName string
	Imports           []string
	Consts            Aliases
	Funcs             Aliases
	Vars              Aliases
	Types             Aliases
}

// ExtractAndAppendAliases pulls alias information out of a parsed go package and appends it to a data structure.
func (td *TemplateData) ExtractAndAppendAliases(pkg *types.Package) {

	td.Imports = append(td.Imports, pkg.Path())

	// iterate through all objects in the package's global scope
	// pick out objects of the relevant type
	// tutorial on golang objects and types: https://github.com/golang/example/tree/master/gotypes
	for _, name := range pkg.Scope().Names() {
		obj := pkg.Scope().Lookup(name)

		if !obj.Exported() {
			continue
		}

		switch obj.(type) {
		case *types.Const:
			td.Consts = td.Consts.Append(pkg, obj)
		case *types.Func:
			td.Funcs = td.Funcs.Append(pkg, obj)
		case *types.Var:
			td.Vars = td.Vars.Append(pkg, obj)
		case *types.TypeName:
			td.Types = td.Types.Append(pkg, obj)
		}
	}

	// sort the aliases to create a canonical format
	td.Sort()
}

// Sort all sections by alphabetical order.
func (td *TemplateData) Sort() {
	sort.Strings(td.Imports)
	sort.Sort(td.Consts)
	sort.Sort(td.Funcs)
	sort.Sort(td.Vars)
	sort.Sort(td.Types)
}

// Helper function to simplify template logic.
func (td TemplateData) HasVarsOrFuncs() bool {
	return len(td.Vars) > 0 || len(td.Funcs) > 0
}

// Helper function to simplify template logic.
func (td TemplateData) HasVarsAndFuncs() bool {
	return len(td.Vars) > 0 && len(td.Funcs) > 0
}

type Alias struct {
	Pkg  string
	Name string
}
type Aliases []Alias

func (a Aliases) Append(pkg, obj named) Aliases {
	return append(a,
		Alias{
			Pkg:  pkg.Name(),
			Name: obj.Name(),
		},
	)
}

func (a Aliases) Len() int      { return len(a) }
func (a Aliases) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
func (a Aliases) Less(i, j int) bool {
	if a[i].Pkg != a[j].Pkg {
		return a[i].Pkg < a[j].Pkg
	}
	return a[i].Name < a[j].Name
}

type named interface {
	Name() string
}
